import time

import ujson as json
from starlette.exceptions import HTTPException

from app.clients.insights_api_client import get_axes
from app.clients.openai_client import OpenAIClient
from app.logger import LOGGER
from app.settings import Settings
from .prompt import get_mcda_prompt
from .formatters import set_axis_label, format_bivariate_axis_unit

settings = Settings()


async def get_mcda_suggestion(query: str, bio: str) -> dict:
    axis_data = await get_axes()
    for axis in axis_data['data']['getAxes']['axis']:
        if not axis['label']:
            set_axis_label(axis)
    prompt = await get_mcda_prompt(query, bio, axis_data)
    openai_client = OpenAIClient(
        assistant_name=settings.OPENAI_MCDA_ASSISTANT,
        instructions=settings.OPENAI_MCDA_INSTRUCTIONS,
        override_instructions=True)
    llm_response = await openai_client.get_cached_llm_commentary(prompt)
    return make_valid_mcda(llm_response, axis_data)


def make_valid_mcda(llm_response: str, axis_data: dict) -> dict:
    '''convert json response from LLM to MCDA format accepted by DN-FE'''
    llm_mcda = json.loads(llm_response)
    if 'error' in llm_mcda:
        raise HTTPException(status_code=422, detail=llm_mcda['error'])

    original_request = llm_mcda['original_request']
    analysis_name = llm_mcda['analysis_name']
    indicators_to_axis = {
        (x['quotients'][0]['name'], x['quotients'][1]['name']): x for x in axis_data['data']['getAxes']['axis']
    }
    layers = []
    for llm_layer in llm_mcda['axes']:
        try:
            layers.append(make_mcda_layer(llm_layer, indicators_to_axis))
        except KeyError as e:
            LOGGER.warn('layer suggested by LLM does not exist: %s', e)
    return {
        "type": "mcda",
        "config": {
            "version": 4,
            "id": analysis_name + str(int(time.time())),
            "name": analysis_name,  # generated by AI
            "original_request": original_request,  # what user requested
            "layers": layers,
            "colors": {
                "type": "sentiments",
                "parameters": {
                    "bad": "rgba(228, 26, 28, 0.5)",
                    "good": "rgba(90, 200, 127, 0.5)",
                    "midpoints": [{
                        "value": 0.5,
                        "color": "rgba(251,237,170,0.5)"
                    }]
                }
            }
        }
    }


def make_mcda_layer(llm_axis: dict, indicators_to_axis: dict[tuple, dict]) -> dict:
    '''axis is object returned by LLM, indicators_to_axis is data from insights api'''
    num = llm_axis['numerator']['name']
    den = llm_axis['denominator']['name']
    axis = indicators_to_axis[(num, den)]
    indicators = axis['quotients']
    num, den = indicators
    stats = axis['datasetStats']
    llm_sentiment = ['good', 'bad'] if llm_axis['indicator_evaluation'] == 'lower values are better' else ['bad', 'good']
    return {
        'id': num['name'] + '|' + den['name'],
        'name': axis['label'],
        'comment': llm_axis['comment'],     # AI explains axis choice
        'axis': [num['name'], den['name']],
        'indicators': indicators,
        'unit': format_bivariate_axis_unit(indicators),
        'range': [
            max(stats['minValue'], stats['mean'] - 3*stats['stddev']),
            min(stats['maxValue'], stats['mean'] + 3*stats['stddev']),
        ],
        'datasetStats': axis['datasetStats'],
        'sentiment': llm_sentiment,     # sentiment guessed by AI
        'sentiment_hint': llm_axis['evaluation_hint'],     # explanation by AI
        'outliers': 'clamp',
        'coefficient': 1,
        'transformationFunction': axis['transformation']['transformation'],
        'transformation': axis['transformation'],
        'normalization': 'max-min',
    }
